//// Scanner.llld

letter = [a-zA-Z]
digit = [0-9]

LiteralChar = chr(39) (char | chr(34) | '\' ('\' | 'n' | chr(39))) chr(39);

LiteralFloat = ['-'] digits '.' digits [('e' | 'E') ['-'] digits];
LiteralInt = ['-'] digits;
LiteralString = '"' {char | chr(39) | '\' ('\' | 'n' | '"' | ("x" digits ';'))} '"';

LowerID = lowerID {digit | id};
UpperID = upperID {digit | id};

char = chr(32)-chr(33) + chr(35)-chr(38) + chr(40)-chr(91) + chr(93)-chr(255);
digit = '0'-'9';
digits = digit {digit};
id = 'A'-'Z' + 'a'-'z';
lowerID = 'a'-'z';
upperID = 'A'-'Z';
cr = chr(10);

// Top-Level Structure

Program = { Statement }

Statement = Import | Declaration

Import = 'import' Identifier [ 'as' Identifier ] ';'

Declaration = TypeDecl | AgentDecl

// Types

TypeDecl = 'type' Identifier [ '*' ] [ GenericParams ] '=' TypeExpr { 'and' TypeDeclSuffix } ';'

TypeDeclSuffix = Identifier [ '*' ] [ GenericParams ] '=' TypeExpr

GenericParams = '<' GenericParam { ',' GenericParam } '>'

GenericParam = Identifier [ ':' TypeExpr ]

TypeExpr = RecordType
| VariantUnion
| FunctionType
| GenericType
| BasicType
| LiteralType
| Identifier [ '<' TypeExpr { ',' TypeExpr } '>' ]

RecordType = 'rect' '{' FieldList '}'

FieldList = [ Field { ',' Field } ]

Field = Identifier [ '?' ] ':' TypeExpr

VariantUnion = Variant { '|' Variant }

Variant = Identifier '(' FieldList ')'

FunctionType = TypeExpr '->' TypeExpr

GenericType = Identifier '<' TypeExpr { ',' TypeExpr } '>'

BasicType = 'string' | 'int' | 'float' | 'bool'

LiteralType = string | number | 'true' | 'false'

// Agents

AgentDecl = 'agent' Identifier [ GenericParams ] '[' TypeExpr ',' TypeExpr ']' '(' [ ParamList ] ')' '{' { AgentBody } '}'

AgentBody = StateDecl | InitBlock | Method | Handler

StateDecl = 'let' Identifier ':' TypeExpr '=' Expression ';'

InitBlock = 'init' Block

Method = 'fn' Identifier [ '*' ] '(' [ ParamList ] ')' [ ':' TypeExpr ] '=>' ( Expression | Block )

Handler = 'on' Identifier ':' TypeExpr '=>' Expression ';'

ParamList = Param { ',' Param }

Param = Identifier ':' TypeExpr

// Expressions

Expression = Literal
| Identifier
| Expression BinaryOp Expression
| 'if' Expression 'then' Expression 'else' Expression
| 'match' Expression '{' { MatchCase } '}'
| 'emit' '(' Identifier ',' Expression ')'
| 'println' '(' Expression ')'
| 'rect' '{' FieldAssignments '}'
| LambdaExpr
| ForExpr
| WhileExpr
| OptionalExpr
| Block

LambdaExpr = Identifier '=>' Expression
| '(' [ ParamList ] ')' '=>' Expression
| '(' [ ParamList ] ')' '=>' Block

ForExpr = 'for' Identifier 'in' Expression Block

WhileExpr = 'while' Expression Block

OptionalExpr = Expression '?'

MatchCase = 'case' Pattern ':' Expression

Pattern = Identifier [ '(' FieldList ')' ]

FieldAssignments = [ FieldAssignment { ',' FieldAssignment } ]

FieldAssignment = Identifier ':' Expression

Block = '{' { Expression } '}'

// Literals and Operators

Literal = number | string | 'true' | 'false'

BinaryOp = '+' | '-' | '*' | '/' | '==' | '!=' | '<' | '>' | '<=' | '>=' | '&&' | '||'

